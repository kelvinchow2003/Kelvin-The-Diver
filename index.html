<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Deep Blue Diver v4.0</title>
<style>

        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');

        body {

            margin: 0;

            overflow: hidden;

            background-color: #000;

            font-family: 'Fredoka', sans-serif;

            touch-action: none;

            user-select: none;

            -webkit-user-select: none;

        }

        canvas { display: block; }

        /* UI Overlay */

        #ui-layer {

            position: absolute; top: 0; left: 0; width: 100%; height: 100%;

            pointer-events: none;

            display: flex; flex-direction: column; justify-content: space-between;

            z-index: 10;

        }

        /* HUD */

        .hud-panel {

            padding: 15px;

            display: flex; justify-content: space-between; width: 100%;

            box-sizing: border-box;

            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);

            color: white;

        }

        .oxygen-container { display: flex; flex-direction: column; gap: 5px; }

        .bar-frame {

            width: 200px; height: 24px;

            background: rgba(0,0,0,0.6);

            border-radius: 12px; border: 2px solid rgba(255,255,255,0.3);

            overflow: hidden; position: relative;

        }

        .bar-fill {

            height: 100%; width: 100%;

            background: linear-gradient(90deg, #e74c3c, #f1c40f, #2ecc71);

            transition: width 0.2s;

        }

        .info-box {

            text-align: right; background: rgba(0,0,0,0.4);

            padding: 10px; border-radius: 8px; backdrop-filter: blur(4px);

        }

        .stat-row {

            display: flex; justify-content: flex-end; gap: 10px;

            margin-bottom: 4px; font-weight: 600; font-size: 18px;

        }

        /* Boss Bar */

        #boss-hud {

            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);

            width: 60%; display: none; flex-direction: column; align-items: center;

        }

        .boss-bar-frame {

            width: 100%; height: 30px; border: 3px solid #fff;

            background: #440000; border-radius: 15px; overflow: hidden;

        }

        .boss-bar-fill {

            height: 100%; width: 100%; background: #e74c3c;

            transition: width 0.1s;

        }

        .boss-label {

            color: #e74c3c; font-size: 24px; font-weight: bold; 

            text-shadow: 2px 2px 0 #000; margin-bottom: 5px;

        }

        /* Controls */

        .controls-layer {

            pointer-events: auto; padding: 20px;

            display: flex; justify-content: space-between; align-items: flex-end;

            height: 180px; opacity: 0.8;

        }

        @media (min-width: 1024px) { .controls-layer { display: none; } }

        .joystick-zone {

            width: 100px; height: 100px;

            background: rgba(255, 255, 255, 0.1);

            border: 2px solid rgba(255, 255, 255, 0.3);

            border-radius: 50%;

            position: relative; display: flex; justify-content: center; align-items: center;

        }

        .joystick-knob {

            width: 40px; height: 40px;

            background: rgba(255, 255, 255, 0.8);

            border-radius: 50%; position: absolute;

            box-shadow: 0 4px 10px rgba(0,0,0,0.5);

        }

        .dash-btn {

            width: 70px; height: 70px;

            border-radius: 50%; background: #f39c12;

            border: 3px solid white; color: white;

            font-weight: bold; font-size: 14px;

            display: flex; justify-content: center; align-items: center;

            margin-bottom: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.5);

            cursor: pointer;

        }

        .dash-btn:active { transform: scale(0.9); background: #d35400; }

        .control-group-right { display: flex; flex-direction: column; align-items: flex-end; gap: 20px; }

        /* Shop Modal */

        #modal-overlay {

            position: absolute; top: 0; left: 0; width: 100%; height: 100%;

            background: rgba(0,10,20,0.9);

            display: none; justify-content: center; align-items: center;

            pointer-events: auto; z-index: 1000; backdrop-filter: blur(8px);

        }

        .shop-card {

            background: #1a2634; width: 90%; max-width: 450px;

            border-radius: 15px; border: 1px solid #34495e;

            box-shadow: 0 20px 60px rgba(0,0,0,0.8);

            overflow: hidden; color: white; animation: popIn 0.3s ease;

        }

        @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .shop-header { background: #2c3e50; padding: 20px; text-align: center; border-bottom: 1px solid #34495e; }

        .shop-header h2 { margin: 0; color: #f1c40f; }

        .shop-body { padding: 20px; max-height: 60vh; overflow-y: auto; }

        .shop-item {

            background: rgba(255,255,255,0.05); margin-bottom: 10px; padding: 15px;

            border-radius: 8px; display: flex; justify-content: space-between; align-items: center;

        }

        .btn {

            background: #27ae60; border: none; padding: 10px 20px;

            color: white; font-family: 'Fredoka', sans-serif; font-weight: 600;

            border-radius: 6px; cursor: pointer;

        }

        .btn:active { transform: scale(0.95); }

        .btn.disabled { background: #7f8c8d; cursor: not-allowed; opacity: 0.5; }

        .btn-action { width: 100%; font-size: 18px; padding: 15px; margin-top: 10px; background: #3498db; }

        /* Notification */

        .toast {

            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);

            background: rgba(0,0,0,0.8); color: #f1c40f;

            padding: 12px 25px; border-radius: 25px;

            font-size: 22px; pointer-events: none;

            opacity: 0; transition: opacity 0.3s; z-index: 20; border: 1px solid #f1c40f;

        }

        .tutorial {

            position: absolute; bottom: 20px; width: 100%; text-align: center;

            color: rgba(255,255,255,0.5); font-size: 14px; pointer-events: none;

        }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui-layer">
<div class="hud-panel">
<div class="oxygen-container">
<div style="font-size: 14px; font-weight: 600;">OXYGEN</div>
<div class="bar-frame"><div class="bar-fill" id="oxygen-bar"></div></div>
<div style="font-size: 12px; color: #aaa;">DEPTH: <span id="depth-val">0</span>m</div>
</div>
<div class="info-box">
<div class="stat-row"><span style="color: #f1c40f;">$</span><span id="cash-val">0</span></div>
<div class="stat-row"><span style="font-size: 14px;">⚖️</span><span id="weight-val">0</span>/<span id="max-weight-val">10</span></div>
</div>
</div>
<div id="boss-hud">
<div class="boss-label">LEVIATHAN</div>
<div class="boss-bar-frame"><div class="boss-bar-fill" id="boss-fill"></div></div>
</div>
<div id="toast-msg" class="toast"></div>
<div class="controls-layer" id="mobile-controls">
<div class="joystick-zone" id="stick-move">
<div class="joystick-knob" id="knob-move"></div>
</div>
<div class="control-group-right">
<div class="dash-btn" id="btn-dash">DASH</div>
<div class="joystick-zone" id="stick-aim">
<div class="joystick-knob" id="knob-aim"></div>
</div>
</div>
</div>
<div class="tutorial" id="tutorial-text">WASD to Swim • SPACE to Dash • MOUSE to Shoot</div>
</div>
<div id="modal-overlay">
<div class="shop-card">
<div class="shop-header">
<h2>SURFACE DOCK</h2>
<p>Market & Workshop</p>
</div>
<div class="shop-body">
<div style="display: flex; justify-content: space-between; margin-bottom: 20px; font-size: 18px;">
<span>Catch Value:</span>
<span style="color: #2ecc71;">+$<span id="sell-val">0</span></span>
</div>
<button class="btn btn-action" id="sell-btn" style="background: #2ecc71; margin-bottom: 20px;">SELL CATCH</button>
<hr style="border-color: #34495e; opacity: 0.5; margin-bottom: 20px;">
<div class="shop-item">
<div>
<div style="font-weight: bold;">Harpoon Tech</div>
<div style="font-size: 12px; color: #aaa;">Lvl <span id="pow-lvl">1</span> <span id="pow-desc">(Dmg+)</span></div>
</div>
<button class="btn" id="buy-pow">$<span id="pow-cost">200</span></button>
</div>
<div class="shop-item">
<div>
<div style="font-weight: bold;">O2 Tank</div>
<div style="font-size: 12px; color: #aaa;">Lvl <span id="tank-lvl">1</span> (+Air)</div>
</div>
<button class="btn" id="buy-tank">$<span id="tank-cost">100</span></button>
</div>
<div class="shop-item">
<div>
<div style="font-weight: bold;">Cargo Suit</div>
<div style="font-size: 12px; color: #aaa;">Lvl <span id="suit-lvl">1</span> (+Kg)</div>
</div>
<button class="btn" id="buy-suit">$<span id="suit-cost">150</span></button>
</div>
<button class="btn btn-action" id="dive-btn">DIVE!</button>
</div>
</div>
</div>
<script>

/**

 * Deep Blue Diver v4.0 - The Abyssal Update

 * Features: Mines, Treasure, Parallax, Multi-Harpoons, Boss UI

 */

const canvas = document.getElementById('gameCanvas');

const ctx = canvas.getContext('2d');

const maskCanvas = document.createElement('canvas');

const maskCtx = maskCanvas.getContext('2d');

const CFG = {

    gravity: 40,

    waterLevel: 200,

    seaFloor: 8000,

    colors: { sky: '#87CEEB', surface: '#006994', deep: '#000810' },

    darkDepth: 600

};

let state = {

    screen: 'playing',

    lastTime: 0,

    camY: 0,

    shake: 0,

    gameTime: 0

};

const player = {

    x: 0, y: 0, vx: 0, vy: 0,

    angle: 0, aimAngle: 0,

    speed: 300,

    width: 40, height: 20,

    dashCd: 0,

    isDashing: false,

    maxO2: 100, curO2: 100,

    cash: 0, inventory: [], capacity: 10,

    tankLvl: 1, suitLvl: 1, powLvl: 1,

    tankCost: 100, suitCost: 150, powCost: 200,

    harpoonDmg: 1,

    harpoonCount: 1, // For multi-shot

    harpoons: [] // Array for multiple projectiles

};

const input = {

    keys: {},

    mouse: { x: 0, y: 0, down: false },

    stickMove: { x: 0, y: 0, active: false },

    stickAim: { x: 0, y: 0, active: false }

};

// Entities

let fishes = [];

let bubbles = []; 

let o2Bubbles = [];

let mines = [];

let chests = [];

let floatingTexts = [];

let lightRays = [];

let rocksL = [], rocksR = [];

let parallaxMounts = [];

// Data

const FISH_TYPES = [

    { name: "Clowny",  depth: [0, 1000],   hp: 1,  val: 15,  w: 1, spd: 100, col: '#ff9f43', scale: 0.8, aggro: false },

    { name: "Bluefin", depth: [500, 2000], hp: 3,  val: 40,  w: 3, spd: 140, col: '#2e86de', scale: 1.1, aggro: false },

    { name: "Puffer",  depth: [200, 1500], hp: 2,  val: 50,  w: 2, spd: 80,  col: '#feca57', scale: 1.0, aggro: true },

    { name: "Jelly",   depth: [1500, 4000],hp: 4,  val: 90,  w: 1, spd: 50,  col: '#ff9ff3', scale: 1.4, aggro: true, glow: true, glowCol: '#ffccff' },

    { name: "Angler",  depth: [3000, 7500],hp: 8,  val: 250, w: 8, spd: 180, col: '#5f27cd', scale: 2.0, aggro: true, glow: true, glowCol: '#00ffff' },

    { name: "LEVIATHAN",depth: [7800, 8500],hp: 100,val: 5000,w: 50,spd: 120, col: '#e74c3c', scale: 7.0, aggro: true, glow: true, glowCol: '#e74c3c', isBoss: true }

];

// --- Init ---

function init() {

    try {

        resize();

        player.x = canvas.width / 2;

        player.y = CFG.waterLevel + 100; 

        genTerrain();

        spawnRays();

        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {

            document.getElementById('tutorial-text').innerText = "Left: SWIM • Right: AIM • Btn: DASH";

            document.getElementById('mobile-controls').style.display = 'flex';

        }

        requestAnimationFrame(loop);

    } catch (e) {

        console.error("Init failed", e);

        alert("Game Error: " + e.message);

    }

}

function resize() {

    canvas.width = window.innerWidth;

    canvas.height = window.innerHeight;

    if(maskCanvas) { maskCanvas.width = canvas.width; maskCanvas.height = canvas.height; }

    genTerrain();

}

window.addEventListener('resize', resize);

function genTerrain() {

    rocksL = []; rocksR = []; parallaxMounts = []; mines = []; chests = [];

    // Parallax bg mountains

    for(let i=0; i<20; i++) {

        parallaxMounts.push({

            x: Math.random() * canvas.width,

            y: CFG.waterLevel + Math.random() * CFG.seaFloor,

            w: 200 + Math.random() * 300,

            h: 500 + Math.random() * 500

        });

    }

    // Walls & Interactables

    let steps = 100, stepH = CFG.seaFloor / steps;

    for(let i=0; i<=steps; i++) {

        let y = CFG.waterLevel + i * stepH;

        let n = Math.sin(i * 0.2) * 50 + Math.random() * 30;

        let lx = -40 + n;

        let rx = canvas.width + 40 - n;

        rocksL.push({x: lx, y});

        rocksR.push({x: rx, y});

        // Spawn Mines (Deep)

        if (y > 2000 && Math.random() < 0.05) {

            mines.push({ x: Math.random() * (canvas.width - 200) + 100, y: y, r: 15, active: true });

        }

        // Spawn Chests (Ledges)

        if (y > 1000 && Math.random() < 0.03) {

            // Decide Left or Right ledge

            let isLeft = Math.random() < 0.5;

            chests.push({ x: isLeft ? lx + 40 : rx - 60, y: y, w: 30, h: 20, open: false, val: 100 + Math.floor(y/10) });

        }

    }

}

function spawnRays() {

    lightRays = [];

    for(let i=0; i<6; i++) lightRays.push({x: Math.random()*canvas.width, w: 50+Math.random()*100, a: Math.random(), s: 0.2+Math.random()*0.3});

}

// --- Inputs ---

window.addEventListener('keydown', e => {

    input.keys[e.code] = true;

    if(e.code === 'Space') attemptDash();

});

window.addEventListener('keyup', e => input.keys[e.code] = false);

window.addEventListener('mousemove', e => { input.mouse.x = e.clientX; input.mouse.y = e.clientY; });

window.addEventListener('mousedown', () => { 

    if(state.screen === 'playing' && !input.stickAim.active) { input.mouse.down = true; fireHarpoon(); }

});

window.addEventListener('mouseup', () => input.mouse.down = false);

const dashBtn = document.getElementById('btn-dash');

dashBtn.addEventListener('touchstart', (e) => { e.preventDefault(); attemptDash(); });

dashBtn.addEventListener('click', (e) => { e.preventDefault(); attemptDash(); });

function bindStick(eid, kid, obj, onRel) {

    const el = document.getElementById(eid), knob = document.getElementById(kid);

    let sx, sy;

    const move = (cx, cy) => {

        let dx = cx - sx, dy = cy - sy, d = Math.hypot(dx, dy);

        if(d > 40) { dx = (dx/d)*40; dy = (dy/d)*40; }

        knob.style.transform = `translate(${dx}px, ${dy}px)`;

        obj.x = dx/40; obj.y = dy/40; obj.active = true;

    };

    el.addEventListener('touchstart', e => { e.preventDefault(); let r = el.getBoundingClientRect(); sx = r.left+r.width/2; sy = r.top+r.height/2; move(e.touches[0].clientX, e.touches[0].clientY); });

    el.addEventListener('touchmove', e => { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY); });

    el.addEventListener('touchend', e => { e.preventDefault(); obj.x = 0; obj.y = 0; obj.active = false; knob.style.transform = ''; if(onRel) onRel(); });

}

bindStick('stick-move', 'knob-move', input.stickMove);

bindStick('stick-aim', 'knob-aim', input.stickAim, () => { if(state.screen === 'playing') fireHarpoon(); });

// --- Game Logic ---

function attemptDash() {

    if (state.screen !== 'playing') return;

    if (player.curO2 > 5 && player.dashCd <= 0) {

        player.dashCd = 1.0; player.isDashing = true; player.curO2 -= 5;

        let ang = player.angle;

        if (Math.abs(player.vx) < 10 && Math.abs(player.vy) < 10) ang = player.aimAngle;

        const dashPower = 800;

        player.vx = Math.cos(ang) * dashPower; player.vy = Math.sin(ang) * dashPower;

        for(let i=0; i<8; i++) bubbles.push({x: player.x, y: player.y, s: Math.random()*5, v: Math.random()*100, col: 'white'});

        spawnText("DASH!", player.x, player.y - 40, '#3498db');

    }

}

function fireHarpoon() {

    // Find an available harpoon slot or limit based on upgrades

    if (player.harpoons.length >= player.harpoonCount) return;

    // Multi-shot logic (Trident at lvl 5)

    let count = 1;

    if (player.powLvl >= 5) count = 3;

    let baseAng = player.aimAngle;

    for(let i=0; i<count; i++) {

        let offset = 0;

        if (count === 3) offset = (i - 1) * 0.2; // -0.2, 0, +0.2 radians

        player.harpoons.push({

            state: 'fired',

            x: player.x, y: player.y,

            vx: Math.cos(baseAng + offset) * 1000,

            vy: Math.sin(baseAng + offset) * 1000,

            range: 450 + (player.powLvl * 50),

            target: null

        });

    }

    state.shake = 3;

}

function update(dt) {

    state.gameTime += dt;

    if(state.shake > 0) state.shake *= 0.9;

    if(player.dashCd > 0) player.dashCd -= dt;

    if(Math.abs(player.vx) < 400) player.isDashing = false;

    // Movement

    let dx = 0, dy = 0;

    if(input.keys['KeyW']) dy = -1; if(input.keys['KeyS']) dy = 1;

    if(input.keys['KeyA']) dx = -1; if(input.keys['KeyD']) dx = 1;

    if(input.stickMove.active) { dx = input.stickMove.x; dy = input.stickMove.y; }

    if(input.stickAim.active && Math.hypot(input.stickAim.x, input.stickAim.y) > 0.2) {

        player.aimAngle = Math.atan2(input.stickAim.y, input.stickAim.x);

    } else if(!input.stickAim.active) {

        player.aimAngle = Math.atan2(input.mouse.y - (player.y - state.camY), input.mouse.x - player.x);

    }

    const len = Math.hypot(dx, dy);

    if(len > 0.1 && !player.isDashing) {

        player.vx += (dx/len * player.speed - player.vx) * 5 * dt;

        player.vy += (dy/len * player.speed - player.vy) * 5 * dt;

        player.angle = Math.atan2(player.vy, player.vx);

    } else if (!player.isDashing) {

        player.vx *= 0.95; player.vy *= 0.95;

    } else {

        player.vx *= 0.92; player.vy *= 0.92;

    }

    // Bounds & Physics

    if(player.y < CFG.waterLevel) {

        player.vy += 500 * dt; 

        player.curO2 = Math.min(player.maxO2, player.curO2 + 40 * dt);

        if(player.y < CFG.waterLevel - 10 && Math.abs(player.vx) < 30 && state.screen === 'playing') openShop();

    } else {

        player.vy += CFG.gravity * dt;

        player.curO2 -= 1.5 * dt;

        if(player.curO2 <= 0) die();

    }

    player.x = Math.max(50, Math.min(canvas.width - 50, player.x + player.vx * dt));

    player.y = Math.min(CFG.seaFloor, player.y + player.vy * dt);

    // Interact with Chests

    chests.forEach(c => {

        if (!c.open && Math.hypot(player.x - c.x, player.y - c.y) < 40) {

            c.open = true;

            player.cash += c.val;

            spawnText(`+$${c.val}`, c.x, c.y - 30, '#f1c40f');

            // Sparkles

            for(let k=0; k<5; k++) bubbles.push({x: c.x, y: c.y, s: 2, v: 50, col: '#f1c40f'});

        }

    });

    // Mines Collision

    mines.forEach(m => {

        if(m.active && Math.hypot(player.x - m.x, player.y - m.y) < m.r + 15) {

            explodeMine(m);

            player.curO2 -= 30;

            spawnText("-30 O2", player.x, player.y, 'red');

            player.vx = (player.x - m.x) * 20; // Knockback

            player.vy = (player.y - m.y) * 20;

        }

    });

    updateHarpoons(dt);

    updateFish(dt);

    updateEntities(dt);

    state.camY += ((player.y - canvas.height/2) - state.camY) * 4 * dt;

    if(state.camY < -100) state.camY = -100;

    updateUI();

}

function explodeMine(m) {

    m.active = false;

    state.shake = 15;

    // Visuals

    for(let i=0; i<20; i++) bubbles.push({x: m.x, y: m.y, s: Math.random()*8, v: Math.random()*200, col: '#e74c3c'});

    // Damage nearby fish

    fishes.forEach(f => {

        if (Math.hypot(f.x - m.x, f.y - m.y) < 150) {

            f.hp -= 10;

            spawnText("-10", f.x, f.y, 'orange');

            f.vx = (f.x - m.x) * 5;

            f.vy = (f.y - m.y) * 5;

        }

    });

}

function updateHarpoons(dt) {

    for (let i = player.harpoons.length - 1; i >= 0; i--) {

        let h = player.harpoons[i];

        if (h.state === 'fired') {

            h.x += h.vx * dt; h.y += h.vy * dt;

            // Check Mines

            for(let m of mines) {

                if(m.active && Math.hypot(h.x - m.x, h.y - m.y) < m.r + 5) {

                    explodeMine(m);

                    h.state = 'retracting'; // Bounce back

                    break; 

                }

            }

            // Check Fish

            if (h.state === 'fired') {

                for(let f of fishes) {

                    if(Math.hypot(h.x - f.x, h.y - f.y) < 30 * f.scale) {

                        spawnBlood(f.x, f.y);

                        state.shake = 5;

                        f.hp -= player.harpoonDmg;

                        spawnText(`-${player.harpoonDmg}`, f.x, f.y - 20, '#e74c3c');

                        if(f.hp <= 0) {

                            h.state = 'hooked'; h.target = f; h.vx = 0; h.vy = 0;

                        } else {

                            h.state = 'retracting'; f.aggro = true; f.hitFlash = 0.2;

                            f.vx += h.vx * 0.2; 

                        }

                        break;

                    }

                }

            }

            if(Math.hypot(h.x - player.x, h.y - player.y) > h.range) h.state = 'retracting';

        } else if(h.state === 'hooked' || h.state === 'retracting') {

            const ang = Math.atan2(player.y - h.y, player.x - h.x);

            const spd = h.state === 'hooked' ? 500 : 1500;

            h.x += Math.cos(ang) * spd * dt; h.y += Math.sin(ang) * spd * dt;

            if(h.target) {

                h.target.x = h.x; h.target.y = h.y; h.target.vx = 0; h.target.vy = 0;

            }

            if(Math.hypot(player.x - h.x, player.y - h.y) < 30) {

                if(h.target) catchFish(h.target);

                player.harpoons.splice(i, 1); // Remove this harpoon

            }

        }

    }

}

function catchFish(f) {

    const idx = fishes.indexOf(f);

    if (idx === -1) return;

    const cw = player.inventory.reduce((a,b)=>a+b.w,0);

    if(cw + f.w <= player.capacity) {

        player.inventory.push(f);

        fishes.splice(idx, 1);

        spawnText(`+${f.name}`, player.x, player.y - 50, '#f1c40f');

    } else {

        spawnText("FULL!", player.x, player.y - 50, 'red');

        f.x += (Math.random()-0.5)*200; f.vx = 200; f.hp = 1;

    }

}

function updateFish(dt) {

    // Spawning

    if(fishes.length < 20) {

        const type = FISH_TYPES[Math.floor(Math.random() * FISH_TYPES.length)];

        if (type.isBoss) { if (fishes.find(f => f.isBoss)) return; }

        const sy = Math.max(CFG.waterLevel+200, type.depth[0] + Math.random()*(type.depth[1]-type.depth[0]));

        if(Math.abs(sy - player.y) < 1500) {

             const side = Math.random() < 0.5 ? -100 : canvas.width+100;

             fishes.push({ ...type, x: side, y: sy, vx: (side<0?1:-1)*type.spd, vy: 0, facing: side<0?1:-1, anim: Math.random()*10, hitFlash: 0, maxHp: type.hp });

        }

    }

    let bossActive = false;

    for(let i=fishes.length-1; i>=0; i--) {

        let f = fishes[i];

        let hooked = false;

        // Check if hooked by ANY harpoon

        for(let h of player.harpoons) if(h.target === f) hooked = true;

        if(hooked) continue;

        if (f.isBoss) {

            bossActive = true;

            updateBossUI(f);

        }

        if(f.hitFlash > 0) f.hitFlash -= dt;

        f.anim += dt * 5;

        f.x += f.vx * dt;

        f.y += Math.sin(f.anim) * 0.5;

        if(Math.abs(f.y - player.y) > 2500 && !f.isBoss) { fishes.splice(i,1); continue; }

        if(f.x < -200 || f.x > canvas.width+200) { f.vx *= -1; f.facing *= -1; }

        if(f.aggro) {

            const dist = Math.hypot(player.x - f.x, player.y - f.y);

            if(dist < 300) {

                const ang = Math.atan2(player.y - f.y, player.x - f.x);

                f.vx = Math.cos(ang) * f.spd * 1.5;

                f.y += Math.sin(ang) * f.spd * 1.5 * dt;

                f.facing = f.vx > 0 ? 1 : -1;

                if(dist < 40 * f.scale && !player.isDashing) {

                    player.curO2 -= (f.isBoss ? 40 : 15);

                    state.shake = 10;

                    spawnText("-" + (f.isBoss ? 40 : 15) + " O2", player.x, player.y, 'red');

                    player.vx += Math.cos(ang)*300; player.vy += Math.sin(ang)*300;

                    f.x -= Math.cos(ang)*100;

                }

            }

        }

    }

    if (!bossActive) document.getElementById('boss-hud').style.display = 'none';

}

function updateBossUI(f) {

    const hud = document.getElementById('boss-hud');

    const fill = document.getElementById('boss-fill');

    hud.style.display = 'flex';

    const pct = Math.max(0, (f.hp / f.maxHp) * 100);

    fill.style.width = `${pct}%`;

}

function updateEntities(dt) {

    if(Math.random() < 0.005 && player.y > 1000) o2Bubbles.push({x: Math.random()*canvas.width, y: player.y + 600, vy: -50});

    for(let i=o2Bubbles.length-1; i>=0; i--) {

        let b = o2Bubbles[i]; b.y += b.vy * dt;

        if(Math.hypot(player.x - b.x, player.y - b.y) < 40) {

            player.curO2 = Math.min(player.maxO2, player.curO2 + 25);

            spawnText("+25 O2", player.x, player.y, '#2ecc71'); o2Bubbles.splice(i, 1);

        } else if (b.y < CFG.waterLevel) o2Bubbles.splice(i, 1);

    }

    if(Math.random() < 0.1) bubbles.push({x: player.x, y: player.y, s: Math.random()*4+2, v: Math.random()*50+20});

    for(let i=bubbles.length-1; i>=0; i--) {

        let b = bubbles[i]; b.y -= b.v * dt; b.x += Math.sin(b.y*0.05)*0.5;

        if(b.y < CFG.waterLevel) bubbles.splice(i, 1);

    }

    for(let i=floatingTexts.length-1; i>=0; i--) {

        let t = floatingTexts[i]; t.y -= 30 * dt; t.life -= dt;

        if(t.life <= 0) floatingTexts.splice(i, 1);

    }

    lightRays.forEach(r => r.x += Math.sin(state.gameTime * r.s) * 0.2);

}

// --- Drawing ---

function draw() {

    let sx = (Math.random()-0.5)*state.shake, sy = (Math.random()-0.5)*state.shake;

    ctx.save();

    ctx.translate(sx, sy - state.camY);

    // Sky & Water

    ctx.fillStyle = CFG.colors.sky; ctx.fillRect(0, state.camY-100, canvas.width, canvas.height+200);

    ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(canvas.width-100, -200, 80, 0, Math.PI*2); ctx.fill();

    let grad = ctx.createLinearGradient(0, CFG.waterLevel, 0, CFG.seaFloor);

    grad.addColorStop(0, CFG.colors.surface); grad.addColorStop(0.4, '#001e3c'); grad.addColorStop(1, CFG.colors.deep);

    ctx.fillStyle = grad; ctx.fillRect(0, CFG.waterLevel, canvas.width, CFG.seaFloor+1000);

    // Parallax Mountains

    ctx.save();

    ctx.translate(0, state.camY * 0.5); // Parallax effect

    ctx.fillStyle = '#001020';

    parallaxMounts.forEach(m => {

        ctx.beginPath(); ctx.moveTo(m.x, m.y); ctx.lineTo(m.x - m.w/2, m.y + m.h); ctx.lineTo(m.x + m.w/2, m.y + m.h); ctx.fill();

    });

    ctx.restore();

    // Terrain

    ctx.fillStyle = '#1e272e';

    if (rocksL.length > 0) {

        ctx.beginPath(); ctx.moveTo(rocksL[0].x, rocksL[0].y); for(let p of rocksL) ctx.lineTo(p.x, p.y); ctx.lineTo(-500, CFG.seaFloor); ctx.lineTo(-500, CFG.waterLevel); ctx.fill();

        ctx.beginPath(); ctx.moveTo(rocksR[0].x, rocksR[0].y); for(let p of rocksR) ctx.lineTo(p.x, p.y); ctx.lineTo(canvas.width+500, CFG.seaFloor); ctx.lineTo(canvas.width+500, CFG.waterLevel); ctx.fill();

    }

    // Chests

    chests.forEach(c => {

        ctx.save(); ctx.translate(c.x, c.y);

        ctx.fillStyle = c.open ? '#555' : '#f1c40f';

        ctx.fillRect(-15, -20, 30, 20);

        ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.strokeRect(-15, -20, 30, 20);

        ctx.restore();

    });

    // Mines

    ctx.fillStyle = '#333';

    mines.forEach(m => {

        if(!m.active) return;

        ctx.beginPath(); ctx.arc(m.x, m.y, m.r, 0, Math.PI*2); ctx.fill();

        // Spikes

        for(let i=0; i<6; i++) {

            let a = i * (Math.PI/3);

            ctx.beginPath(); ctx.moveTo(m.x + Math.cos(a)*m.r, m.y + Math.sin(a)*m.r);

            ctx.lineTo(m.x + Math.cos(a)*(m.r+5), m.y + Math.sin(a)*(m.r+5)); ctx.strokeStyle='red'; ctx.lineWidth=2; ctx.stroke();

        }

    });

    ctx.fillStyle = '#e55039'; ctx.fillRect(canvas.width/2-60, CFG.waterLevel-30, 120, 35);

    ctx.fillStyle = '#ecf0f1'; ctx.fillRect(canvas.width/2-10, CFG.waterLevel-70, 40, 40);

    ctx.fillStyle = 'rgba(255,255,255,0.2)'; bubbles.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, b.s, 0, Math.PI*2); ctx.fill(); });

    o2Bubbles.forEach(b => {

        ctx.save(); ctx.translate(b.x, b.y); ctx.shadowBlur=10; ctx.shadowColor='#00ff00';

        ctx.fillStyle = 'rgba(100, 255, 100, 0.5)'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText("O2", -8, 4); ctx.restore();

    });

    fishes.forEach(f => { 

        let hooked = false; 

        for(let h of player.harpoons) if(h.target===f) hooked=true;

        if(!hooked) drawFish(f); 

    });

    player.harpoons.forEach(h => drawHarpoon(h));

    drawPlayer();

    drawLighting();

    floatingTexts.forEach(t => { ctx.fillStyle = t.col; ctx.font = 'bold 20px Fredoka'; ctx.fillText(t.txt, t.x, t.y); });

    ctx.restore();

}

function drawPlayer() {

    ctx.save(); ctx.translate(player.x, player.y);

    let rot = player.aimAngle; let flip = 1;

    if(Math.abs(rot) > Math.PI/2) { flip = -1; rot = Math.PI - rot; }

    ctx.scale(1, flip); ctx.rotate(rot);

    if(player.isDashing) {

        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';

        ctx.beginPath(); ctx.moveTo(-30, -10); ctx.lineTo(-60, 0); ctx.lineTo(-30, 10); ctx.fill();

    }

    let fin = Math.sin(state.gameTime*15)*5;

    ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(-15, 5); ctx.lineTo(-30, 10+fin); ctx.lineTo(-28, 0); ctx.fill();

    ctx.beginPath(); ctx.moveTo(-15, -5); ctx.lineTo(-30, -10-fin); ctx.lineTo(-28, 0); ctx.fill();

    ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.roundRect(-10, -12, 20, 8, 4); ctx.fill();

    ctx.fillStyle = '#34495e'; ctx.beginPath(); ctx.ellipse(0, 0, 22, 10, 0, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = '#7bed9f'; ctx.beginPath(); ctx.arc(12, -2, 6, 0, Math.PI*2); ctx.fill();

    // Gun visuals based on level

    ctx.fillStyle = player.powLvl >= 3 ? '#3498db' : '#95a5a6'; 

    ctx.fillRect(5, 2, 15, 4);

    if(player.powLvl >= 5) { ctx.fillRect(5, -2, 15, 2); ctx.fillRect(5, 6, 15, 2); } // Trident look

    // Laser

    if(state.screen === 'playing') {

        ctx.strokeStyle = 'rgba(255,0,0,0.3)'; ctx.setLineDash([5,5]); ctx.lineWidth = 1;

        ctx.beginPath(); ctx.moveTo(20, 4); ctx.lineTo(300, 4); ctx.stroke(); ctx.setLineDash([]);

    }

    ctx.restore();

}

function drawFish(f) {

    ctx.save(); ctx.translate(f.x, f.y); ctx.scale(f.facing*f.scale, f.scale);

    ctx.fillStyle = f.hitFlash > 0 ? '#fff' : f.col;

    ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2;

    ctx.beginPath(); ctx.moveTo(15, 0); ctx.bezierCurveTo(5, -15, -15, -10, -20, 0); ctx.bezierCurveTo(-15, 10, 5, 15, 15, 0); ctx.fill(); ctx.stroke();

    let tail = Math.sin(f.anim)*5;

    ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(-30, -10+tail); ctx.lineTo(-30, 10+tail); ctx.closePath(); ctx.fill(); ctx.stroke();

    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(8, -4, 4, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(9, -4, 1.5, 0, Math.PI*2); ctx.fill();

    if(f.hp < f.maxHp) {

        ctx.fillStyle = 'red'; ctx.fillRect(-10, -20, 20, 4);

        ctx.fillStyle = '#00ff00'; ctx.fillRect(-10, -20, 20 * (f.hp/f.maxHp), 4);

    }

    ctx.restore();

}

function drawHarpoon(h) {

    if(h.state === 'ready') return;

    ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 1.5;

    ctx.beginPath(); ctx.moveTo(player.x, player.y);

    if(h.state === 'retracting') ctx.quadraticCurveTo((player.x+h.x)/2, (player.y+h.y)/2+20, h.x, h.y);

    else ctx.lineTo(h.x, h.y);

    ctx.stroke();

    ctx.save(); ctx.translate(h.x, h.y);

    let ang = (h.state==='retracting') ? Math.atan2(player.y-h.y, player.x-h.x) : Math.atan2(h.vy, h.vx);

    ctx.rotate(ang);

    ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.moveTo(0, -3); ctx.lineTo(15, 0); ctx.lineTo(0, 3); ctx.fill();

    ctx.restore();

    if(h.target) drawFish(h.target);

}

function drawLighting() {

    if(!maskCanvas.width) return;

    const depth = player.y - CFG.waterLevel;

    const dStart = CFG.darkDepth;

    if(depth < dStart) {

        ctx.save(); ctx.globalCompositeOperation = 'overlay';

        let g = ctx.createLinearGradient(0, 0, 0, 600); g.addColorStop(0, 'rgba(255,255,255,0.3)'); g.addColorStop(1, 'transparent');

        ctx.fillStyle = g;

        lightRays.forEach(r => { ctx.beginPath(); ctx.moveTo(r.x, CFG.waterLevel); ctx.lineTo(r.x+Math.sin(r.a)*100, CFG.waterLevel+600); ctx.lineTo(r.x+r.w, CFG.waterLevel); ctx.fill(); });

        ctx.restore(); return;

    }

    const intensity = Math.min(0.96, (depth-dStart)/1500);

    maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

    maskCtx.globalCompositeOperation = 'source-over';

    maskCtx.fillStyle = `rgba(0, 5, 15, ${intensity})`;

    maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);

    maskCtx.globalCompositeOperation = 'destination-out';

    let gAmb = maskCtx.createRadialGradient(player.x, player.y-state.camY, 20, player.x, player.y-state.camY, 180);

    gAmb.addColorStop(0, 'white'); gAmb.addColorStop(1, 'transparent');

    maskCtx.fillStyle = gAmb; maskCtx.beginPath(); maskCtx.arc(player.x, player.y-state.camY, 180, 0, Math.PI*2); maskCtx.fill();

    maskCtx.save(); maskCtx.translate(player.x, player.y-state.camY); maskCtx.rotate(player.aimAngle);

    let gCone = maskCtx.createRadialGradient(0, 0, 10, 0, 0, 450);

    gCone.addColorStop(0, 'rgba(255,255,255,0.9)'); gCone.addColorStop(1, 'transparent');

    maskCtx.fillStyle = gCone;

    maskCtx.beginPath(); maskCtx.moveTo(0, 0); maskCtx.lineTo(450, -100); maskCtx.quadraticCurveTo(500, 0, 450, 100); maskCtx.lineTo(0, 0); maskCtx.fill();

    maskCtx.restore();

    fishes.forEach(f => {

        if(f.glow) {

            let g = maskCtx.createRadialGradient(f.x, f.y-state.camY, 5, f.x, f.y-state.camY, 100);

            g.addColorStop(0, 'rgba(255,255,255,0.8)'); g.addColorStop(1, 'transparent');

            maskCtx.fillStyle = g; maskCtx.beginPath(); maskCtx.arc(f.x, f.y-state.camY, 100, 0, Math.PI*2); maskCtx.fill();

        }

    });

    o2Bubbles.forEach(b => {

        let g = maskCtx.createRadialGradient(b.x, b.y-state.camY, 5, b.x, b.y-state.camY, 50);

        g.addColorStop(0, 'rgba(255,255,255,0.8)'); g.addColorStop(1, 'transparent');

        maskCtx.fillStyle = g; maskCtx.beginPath(); maskCtx.arc(b.x, b.y-state.camY, 50, 0, Math.PI*2); maskCtx.fill();

    });

    ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.drawImage(maskCanvas, 0, 0); ctx.restore();

}

function spawnBlood(x, y) {

    for(let i=0; i<5; i++) bubbles.push({x, y, s: Math.random()*3, v: 10, col: 'red'});

}

function spawnText(txt, x, y, col) {

    floatingTexts.push({txt, x, y, col, life: 1.0});

}

// --- Shop ---

const shopModal = document.getElementById('modal-overlay');

function openShop() {

    state.screen = 'shop'; player.curO2 = player.maxO2;

    shopModal.style.display = 'flex'; updateShopUI();

}

function updateShopUI() {

    document.getElementById('sell-val').innerText = player.inventory.reduce((a,b)=>a+b.val,0);

    document.getElementById('tank-lvl').innerText = player.tankLvl; document.getElementById('tank-cost').innerText = player.tankCost;

    document.getElementById('suit-lvl').innerText = player.suitLvl; document.getElementById('suit-cost').innerText = player.suitCost;

    document.getElementById('pow-lvl').innerText = player.powLvl; document.getElementById('pow-cost').innerText = player.powCost;

    let desc = "(Dmg+)";

    if(player.powLvl === 2) desc = "(Sniper)";

    if(player.powLvl === 4) desc = "(Trident)";

    document.getElementById('pow-desc').innerText = desc;

    const setBtn = (id, cost) => {

        const b = document.getElementById(id);

        if(player.cash < cost) b.classList.add('disabled'); else b.classList.remove('disabled');

    };

    setBtn('buy-tank', player.tankCost); setBtn('buy-suit', player.suitCost); setBtn('buy-pow', player.powCost);

}

document.getElementById('sell-btn').addEventListener('click', () => {

    player.cash += player.inventory.reduce((a,b)=>a+b.val,0); player.inventory = [];

    updateShopUI(); spawnText("SOLD!", player.x, player.y, '#2ecc71');

});

document.getElementById('buy-tank').addEventListener('click', () => {

    if(player.cash >= player.tankCost) { player.cash-=player.tankCost; player.maxO2+=25; player.tankLvl++; player.tankCost=Math.floor(player.tankCost*1.5); updateShopUI(); }

});

document.getElementById('buy-suit').addEventListener('click', () => {

    if(player.cash >= player.suitCost) { player.cash-=player.suitCost; player.capacity+=5; player.suitLvl++; player.suitCost=Math.floor(player.suitCost*1.5); updateShopUI(); }

});

document.getElementById('buy-pow').addEventListener('click', () => {

    if(player.cash >= player.powCost) { 

        player.cash-=player.powCost; player.powLvl++; player.harpoonDmg++; 

        if(player.powLvl >= 5) player.harpoonCount = 3;

        player.powCost=Math.floor(player.powCost*1.5); updateShopUI(); 

    }

});

document.getElementById('dive-btn').addEventListener('click', () => {

    shopModal.style.display = 'none'; state.screen = 'playing';

    player.y = CFG.waterLevel + 60; player.vy = 100; player.vx = 0;

    state.lastTime = performance.now();

});

function die() {

    state.screen = 'dead'; spawnText("RESCUED...", player.x, player.y, 'red');

    player.inventory = [];

    setTimeout(() => { player.x=canvas.width/2; player.y=CFG.waterLevel-50; player.curO2=player.maxO2; openShop(); }, 2000);

}

function updateUI() {

    const pct = Math.max(0, (player.curO2 / player.maxO2) * 100);

    document.getElementById('oxygen-bar').style.width = `${pct}%`;

    document.getElementById('depth-val').innerText = Math.floor(Math.max(0, player.y - CFG.waterLevel) / 10);

    document.getElementById('cash-val').innerText = player.cash;

    const w = player.inventory.reduce((a,b)=>a+b.w,0);

    document.getElementById('weight-val').innerText = w;

    document.getElementById('max-weight-val').innerText = player.capacity;

    document.getElementById('weight-val').style.color = w >= player.capacity ? '#e74c3c' : 'white';

}

function loop(now) {

    const dt = Math.min((now - state.lastTime)/1000, 0.1); state.lastTime = now;

    draw();

    if(state.screen === 'playing') update(dt);

    requestAnimationFrame(loop);

}

window.onload = init;
</script>
</body>
</html>
 