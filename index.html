<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Kelvin The Diver v6.0</title>
<style>

        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap');

        body {

            margin: 0; overflow: hidden; background-color: #000510;

            font-family: 'Fredoka', sans-serif; touch-action: none;

            user-select: none; -webkit-user-select: none;

        }

        canvas { display: block; }

        #error-log {

            position: absolute; top: 0; left: 0; width: 100%; height: 100%;

            background: rgba(0,0,0,0.95); color: #ff4757; padding: 20px;

            display: none; z-index: 99999; font-family: monospace; white-space: pre-wrap;

            overflow: auto; pointer-events: auto;

        }

        #ui-layer {

            position: absolute; top: 0; left: 0; width: 100%; height: 100%;

            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;

            z-index: 10;

        }

        .hud-panel {

            padding: 20px; display: flex; justify-content: space-between; width: 100%; box-sizing: border-box; color: white;

        }

        .stat-pill {

            background: rgba(0, 20, 40, 0.6); backdrop-filter: blur(4px);

            border: 1px solid rgba(255, 255, 255, 0.2); padding: 10px 20px;

            border-radius: 30px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);

        }

        .oxygen-bar-container {

            width: 200px; height: 14px; background: rgba(0,0,0,0.6);

            border-radius: 7px; overflow: hidden; margin-top: 5px;

            border: 1px solid rgba(255,255,255,0.2);

        }

        .oxygen-fill {

            height: 100%; width: 100%; background: linear-gradient(90deg, #e74c3c, #f1c40f, #2ecc71);

            transition: width 0.2s ease-out;

        }

        .stat-text { font-size: 14px; color: #bdc3c7; margin-bottom: 2px; }

        .stat-val { font-size: 20px; font-weight: 800; color: #fff; }

        #boss-hud {

            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);

            width: 70%; display: none; flex-direction: column; align-items: center;

        }

        .boss-bar-frame {

            width: 100%; height: 25px; border: 3px solid #fff;

            background: #2c0404; border-radius: 12px; overflow: hidden;

            box-shadow: 0 5px 15px rgba(0,0,0,0.5);

        }

        .boss-bar-fill { height: 100%; width: 100%; background: #ff4757; transition: width 0.1s; }

        .boss-label { color: #ff4757; font-size: 24px; font-weight: 800; text-shadow: 2px 2px 0 #000; margin-bottom: 5px; }

        .controls-layer {

            pointer-events: auto; padding: 30px;

            display: flex; justify-content: space-between; align-items: flex-end;

            height: 180px; opacity: 0.8;

        }

        @media (min-width: 1024px) { .controls-layer { display: none; } }

        .joystick-zone {

            width: 120px; height: 120px; background: rgba(255, 255, 255, 0.05);

            border: 2px solid rgba(255, 255, 255, 0.1); border-radius: 50%; position: relative;

            display: flex; justify-content: center; align-items: center;

        }

        .joystick-knob {

            width: 50px; height: 50px; background: rgba(255, 255, 255, 0.8);

            border-radius: 50%; position: absolute; box-shadow: 0 4px 10px rgba(0,0,0,0.3);

        }

        .dash-btn {

            width: 80px; height: 80px; border-radius: 50%;

            background: radial-gradient(circle at 30% 30%, #f1c40f, #e67e22);

            border: 3px solid white; color: white; font-weight: bold;

            display: flex; justify-content: center; align-items: center;

            margin-bottom: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.4); cursor: pointer;

        }

        .control-group-right { display: flex; flex-direction: column; align-items: flex-end; gap: 20px; }

        #modal-overlay {

            position: absolute; top: 0; left: 0; width: 100%; height: 100%;

            background: rgba(0, 10, 20, 0.95);

            display: none; justify-content: center; align-items: center;

            pointer-events: auto; z-index: 1000; backdrop-filter: blur(5px);

        }

        .shop-card {

            background: #1e272e; width: 90%; max-width: 450px;

            border-radius: 20px; border: 1px solid #485460;

            box-shadow: 0 20px 50px black; overflow: hidden; color: white;

        }

        .shop-header { background: #0fb9b1; padding: 20px; text-align: center; }

        .shop-header h2 { margin: 0; color: white; text-shadow: 0 2px 0 rgba(0,0,0,0.2); }

        .shop-body { padding: 20px; }

        .shop-item {

            background: rgba(0,0,0,0.2); margin-bottom: 10px; padding: 15px;

            border-radius: 10px; display: flex; justify-content: space-between; align-items: center;

        }

        .btn {

            background: #0fb9b1; border: none; padding: 10px 20px;

            color: white; font-family: inherit; font-weight: bold;

            border-radius: 6px; cursor: pointer;

        }

        .btn.disabled { background: #57606f; opacity: 0.5; }

        .btn-action { width: 100%; font-size: 18px; padding: 15px; margin-top: 10px; background: #4b7bec; }

        .toast {

            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);

            background: rgba(0,0,0,0.8); color: #f1c40f;

            padding: 15px 30px; border-radius: 30px; border: 2px solid #f1c40f;

            font-size: 24px; font-weight: bold; pointer-events: none;

            opacity: 0; transition: opacity 0.3s; z-index: 100;

        }

        .tutorial {

            position: absolute; bottom: 20px; width: 100%; text-align: center;

            color: rgba(255,255,255,0.5); font-size: 12px; text-transform: uppercase; letter-spacing: 1px;

        }
</style>
</head>
<body>
<div id="error-log"></div>
<canvas id="gameCanvas"></canvas>
<canvas id="maskCanvas" style="display:none;"></canvas>
<div id="ui-layer">
<div class="hud-panel">
<div class="stat-pill">
<div class="stat-text">OXYGEN</div>
<div class="oxygen-bar-container"><div class="oxygen-fill" id="oxygen-bar"></div></div>
<div style="margin-top: 4px; font-size: 12px; text-align: right;"><span id="depth-val">0</span>m</div>
</div>
<div class="stat-pill" style="text-align: right;">
<div class="stat-text">FUNDS & CARGO</div>
<div class="stat-val" style="color: #f1c40f;">$<span id="cash-val">0</span></div>
<div style="font-size: 14px;"><span id="weight-val">0</span>/<span id="max-weight-val">10</span> kg</div>
</div>
</div>
<div id="boss-hud">
<div class="boss-label">L E V I A T H A N</div>
<div class="boss-bar-frame"><div class="boss-bar-fill" id="boss-fill"></div></div>
</div>
<div id="toast-msg" class="toast"></div>
<div class="controls-layer" id="mobile-controls">
<div class="joystick-zone" id="stick-move">
<div class="joystick-knob" id="knob-move"></div>
</div>
<div class="control-group-right">
<div class="dash-btn" id="btn-dash">BOOST</div>
<div class="joystick-zone" id="stick-aim">
<div class="joystick-knob" id="knob-aim"></div>
</div>
</div>
</div>
<div class="tutorial" id="tutorial-text">WASD to Swim • SPACE to Boost • MOUSE to Aim/Shoot</div>
</div>
<div id="modal-overlay">
<div class="shop-card">
<div class="shop-header">
<h2>THE DRY DOCK</h2>
</div>
<div class="shop-body">
<div style="display: flex; justify-content: space-between; margin-bottom: 20px; font-size: 18px;">
<span>Cargo Value:</span>
<span style="color: #2ecc71;">+$<span id="sell-val">0</span></span>
</div>
<button class="btn btn-action" id="sell-btn" style="background: #f1c40f; color: #000; margin-bottom: 20px;">SELL ALL</button>
<div class="shop-item">
<div>
<div style="font-weight: bold;">Harpoon Tech</div>
<div style="font-size: 12px; color: #aaa;">Level <span id="pow-lvl">1</span> <span id="pow-desc">(Base)</span></div>
</div>
<button class="btn" id="buy-pow">$<span id="pow-cost">200</span></button>
</div>
<div class="shop-item">
<div>
<div style="font-weight: bold;">O2 Tank</div>
<div style="font-size: 12px; color: #aaa;">Level <span id="tank-lvl">1</span> (+Air)</div>
</div>
<button class="btn" id="buy-tank">$<span id="tank-cost">100</span></button>
</div>
<div class="shop-item">
<div>
<div style="font-weight: bold;">Cargo Suit</div>
<div style="font-size: 12px; color: #aaa;">Level <span id="suit-lvl">1</span> (+Kg)</div>
</div>
<button class="btn" id="buy-suit">$<span id="suit-cost">150</span></button>
</div>
<button class="btn btn-action" id="dive-btn">DIVE DEEP</button>
</div>
</div>
</div>
<script>

/**

 * Deep Blue Diver v6.2 - The Angler's Maw

 * Changes: 

 * 1. Completely redesigned Anglerfish with a more prominent jaw and a full set of needle-like teeth, as requested.

 */

window.onerror = function(msg, url, lineNo, columnNo, error) {

    const div = document.getElementById('error-log');

    div.style.display = 'block';

    div.innerText += `Error: ${msg}\nLine: ${lineNo}\n\n`;

    return false;

};

const canvas = document.getElementById('gameCanvas');

const ctx = canvas.getContext('2d');

const maskCanvas = document.createElement('canvas');

const maskCtx = maskCanvas.getContext('2d');

function drawRoundRect(ctx, x, y, w, h, r) {

    if (w < 2 * r) r = w / 2;

    if (h < 2 * r) r = h / 2;

    ctx.beginPath();

    ctx.moveTo(x+r, y);

    ctx.arcTo(x+w, y,   x+w, y+h, r);

    ctx.arcTo(x+w, y+h, x,   y+h, r);

    ctx.arcTo(x,   y+h, x,   y,   r);

    ctx.arcTo(x,   y,   x+w, y,   r);

    ctx.closePath();

    ctx.fill();

}

let patRock, patSand;

function createTextures() {

    try {

        const rc = document.createElement('canvas'); rc.width = 100; rc.height = 100;

        const rctx = rc.getContext('2d');

        rctx.fillStyle = '#2d3436'; rctx.fillRect(0,0,100,100);

        for(let i=0; i<300; i++) {

            rctx.fillStyle = Math.random() > 0.5 ? '#353b48' : '#1e272e';

            rctx.fillRect(Math.random()*100, Math.random()*100, 4, 4);

        }

        patRock = ctx.createPattern(rc, 'repeat');

        const sc = document.createElement('canvas'); sc.width = 100; sc.height = 100;

        const sctx = sc.getContext('2d');

        sctx.fillStyle = '#dcdde1'; sctx.fillRect(0,0,100,100); 

        for(let i=0; i<500; i++) {

            sctx.fillStyle = 'rgba(0,0,0,0.1)';

            sctx.fillRect(Math.random()*100, Math.random()*100, 2, 2);

        }

        patSand = ctx.createPattern(sc, 'repeat');

    } catch(e) { console.warn("Texture gen failed"); }

}

const CFG = {

    gravity: 40, waterLevel: 200, seaFloor: 8000,

    colors: { sky: ['#87CEEB', '#B0E0E6'], surface: ['#006994', '#001e3c', '#000810'] },

    darkDepth: 600

};

let state = { screen: 'playing', lastTime: 0, camY: 0, shake: 0, gameTime: 0 };

const player = {

    x: 0, y: 0, vx: 0, vy: 0, angle: 0, aimAngle: 0, speed: 320,

    dashCd: 0, isDashing: false,

    maxO2: 100, curO2: 100, cash: 0, inventory: [], capacity: 10,

    invincibleTimer: 0, doubleCapacity: false,

    tankLvl: 1, suitLvl: 1, powLvl: 1,

    tankCost: 100, suitCost: 150, powCost: 200,

    harpoonDmg: 1, harpoonCount: 1,

    harpoons: [] 

};

const input = {

    keys: {}, mouse: { x: 0, y: 0, down: false },

    stickMove: { x: 0, y: 0, active: false }, stickAim: { x: 0, y: 0, active: false }

};

let fishes = [], bubbles = [], o2Bubbles = [], powerups = [], mines = [], chests = [], floatingTexts = [], lightRays = [];

let rocksL = [], rocksR = [], particles = [], ambientBubbles = [];

let waveOffset = 0;

// Updated Leviathan speed to 240

const FISH_TYPES = [

    { name: "Clowny", depth: [0, 1000], hp: 1, val: 15, w: 1, spd: 100, col: '#e17055', scale: 0.8, type: 'small' },

    { name: "Bluefin", depth: [500, 2000], hp: 3, val: 40, w: 3, spd: 140, col: '#0984e3', scale: 1.1, type: 'med' },

    { name: "Puffer", depth: [200, 1500], hp: 2, val: 50, w: 2, spd: 80, col: '#fdcb6e', scale: 1.0, type: 'puffer', spikes: true },

    { name: "Jelly", depth: [1500, 4000], hp: 4, val: 90, w: 1, spd: 50, col: '#e056fd', scale: 1.4, type: 'jelly', aggro: true, glow: true },

    { name: "Stingray", depth: [2500, 6000], hp: 6, val: 120, w: 4, spd: 90, col: '#a29bfe', scale: 1.5, type: 'ray', aggro: false },

    { name: "Angler", depth: [3000, 7500], hp: 8, val: 250, w: 8, spd: 160, col: '#4834d4', scale: 2.2, type: 'angler', aggro: true, glow: true },

    { name: "LEVIATHAN", depth: [7800, 8500], hp: 120, val: 5000, w: 50, spd: 240, col: '#d63031', scale: 1.0, type: 'boss', aggro: true, glow: true, isBoss: true }

];

// --- Init ---

function init() {

    try {

        resize();

        createTextures();

        player.x = canvas.width / 2; player.y = CFG.waterLevel + 100; 

        genTerrain();

        for(let i=0; i<60; i++) particles.push({ x: Math.random()*canvas.width, y: Math.random()*CFG.seaFloor, s: Math.random()*2, v: Math.random()*10+5 });

        for(let i=0; i<10; i++) lightRays.push({x: Math.random()*canvas.width, w: 50+Math.random()*100, a: Math.random(), s: 0.2+Math.random()*0.3});

        for(let i=0; i<50; i++) ambientBubbles.push({x: Math.random()*canvas.width, y: CFG.waterLevel + Math.random()*CFG.seaFloor, s: Math.random()*3+1, v: Math.random()*30+20});

        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {

            document.getElementById('tutorial-text').innerText = "Left: SWIM • Right: AIM • Btn: BOOST";

            document.getElementById('mobile-controls').style.display = 'flex';

        }

        requestAnimationFrame(loop);

    } catch (e) {

        document.getElementById('error-log').style.display = 'block';

        document.getElementById('error-log').innerText = "INIT ERROR: " + e.message;

    }

}

function resize() {

    canvas.width = window.innerWidth; canvas.height = window.innerHeight;

    maskCanvas.width = canvas.width; maskCanvas.height = canvas.height;

    genTerrain();

}

window.addEventListener('resize', resize);

function genTerrain() {

    rocksL = []; rocksR = []; mines = []; chests = []; powerups = [];

    let steps = 120, stepH = CFG.seaFloor / steps;

    for(let i=0; i<=steps; i++) {

        let y = CFG.waterLevel + i * stepH;

        let n = Math.sin(i * 0.15) * 70 + Math.sin(i * 0.5) * 30 + Math.random() * 20;

        let lx = -30 + n; let rx = canvas.width + 30 - n;

        rocksL.push({x: lx, y}); rocksR.push({x: rx, y});

        if (y > 2000 && Math.random() < 0.05) mines.push({ x: Math.random() * (canvas.width - 200) + 100, y: y, r: 16, active: true });

        if (y > 1000 && Math.random() < 0.03) chests.push({ x: Math.random()<0.5 ? lx+40 : rx-40, y: y, open: false, val: 100 + Math.floor(y/10) });

    }

}

// --- Inputs ---

window.addEventListener('keydown', e => { input.keys[e.code] = true; if(e.code === 'Space') attemptDash(); });

window.addEventListener('keyup', e => input.keys[e.code] = false);

window.addEventListener('mousemove', e => { input.mouse.x = e.clientX; input.mouse.y = e.clientY; });

window.addEventListener('mousedown', () => { if(state.screen === 'playing' && !input.stickAim.active) { input.mouse.down = true; fireHarpoon(); }});

window.addEventListener('mouseup', () => input.mouse.down = false);

const dashBtn = document.getElementById('btn-dash');

dashBtn.addEventListener('touchstart', (e) => { e.preventDefault(); attemptDash(); });

dashBtn.addEventListener('click', (e) => { e.preventDefault(); attemptDash(); });

function bindStick(eid, kid, obj, onRel) {

    const el = document.getElementById(eid), knob = document.getElementById(kid);

    let sx, sy;

    const move = (cx, cy) => {

        let dx = cx - sx, dy = cy - sy, d = Math.hypot(dx, dy);

        if(d > 40) { dx = (dx/d)*40; dy = (dy/d)*40; }

        knob.style.transform = `translate(${dx}px, ${dy}px)`;

        obj.x = dx/40; obj.y = dy/40; obj.active = true;

    };

    el.addEventListener('touchstart', e => { e.preventDefault(); let r = el.getBoundingClientRect(); sx = r.left+r.width/2; sy = r.top+r.height/2; move(e.touches[0].clientX, e.touches[0].clientY); });

    el.addEventListener('touchmove', e => { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY); });

    el.addEventListener('touchend', e => { e.preventDefault(); obj.x = 0; obj.y = 0; obj.active = false; knob.style.transform = ''; if(onRel) onRel(); });

}

bindStick('stick-move', 'knob-move', input.stickMove);

bindStick('stick-aim', 'knob-aim', input.stickAim, () => { if(state.screen === 'playing') fireHarpoon(); });

// --- Game Logic ---

function attemptDash() {

    if (state.screen !== 'playing') return;

    if (player.curO2 > 5 && player.dashCd <= 0) {

        player.dashCd = 1.0; player.isDashing = true; player.curO2 -= 5;

        let ang = player.angle;

        if (Math.abs(player.vx) < 10 && Math.abs(player.vy) < 10) ang = player.aimAngle;

        const pwr = 900;

        player.vx = Math.cos(ang) * pwr; player.vy = Math.sin(ang) * pwr;

        for(let i=0; i<10; i++) bubbles.push({x: player.x, y: player.y, s: Math.random()*6, v: Math.random()*100, col: 'rgba(255,255,255,0.6)'});

        spawnText("BOOST!", player.x, player.y - 40, '#2ecc71');

    }

}

function fireHarpoon() {

    if (player.harpoons.length >= player.harpoonCount) return;

    let count = player.powLvl >= 5 ? 3 : 1;

    let baseAng = player.aimAngle;

    for(let i=0; i<count; i++) {

        let offset = count === 3 ? (i-1)*0.2 : 0;

        player.harpoons.push({

            state: 'fired', x: player.x, y: player.y,

            vx: Math.cos(baseAng + offset) * 1100, vy: Math.sin(baseAng + offset) * 1100,

            range: 450 + (player.powLvl * 50), target: null

        });

    }

    state.shake = 4;

}

function update(dt) {

    state.gameTime += dt;

    waveOffset += dt * 3;

    if(state.shake > 0) state.shake *= 0.9;

    if(player.dashCd > 0) player.dashCd -= dt;

    if(player.invincibleTimer > 0) player.invincibleTimer -= dt;

    if(Math.abs(player.vx) < 400) player.isDashing = false;

    let dx = 0, dy = 0;

    if(input.keys['KeyW']) dy = -1; if(input.keys['KeyS']) dy = 1;

    if(input.keys['KeyA']) dx = -1; if(input.keys['KeyD']) dx = 1;

    if(input.stickMove.active) { dx = input.stickMove.x; dy = input.stickMove.y; }

    if(input.stickAim.active && Math.hypot(input.stickAim.x, input.stickAim.y) > 0.2) {

        player.aimAngle = Math.atan2(input.stickAim.y, input.stickAim.x);

    } else if(!input.stickAim.active) {

        player.aimAngle = Math.atan2(input.mouse.y - (player.y - state.camY), input.mouse.x - player.x);

    }

    const len = Math.hypot(dx, dy);

    if(len > 0.1 && !player.isDashing) {

        player.vx += (dx/len * player.speed - player.vx) * 5 * dt;

        player.vy += (dy/len * player.speed - player.vy) * 5 * dt;

        player.angle = Math.atan2(player.vy, player.vx);

    } else if (!player.isDashing) {

        player.vx *= 0.95; player.vy *= 0.95;

    } else {

        player.vx *= 0.94; player.vy *= 0.94; 

    }

    if(player.y < CFG.waterLevel) {

        player.vy += 600 * dt; 

        player.curO2 = Math.min(player.maxO2, player.curO2 + 50 * dt);

        if(player.y < CFG.waterLevel - 10 && Math.abs(player.vx) < 30 && state.screen === 'playing') openShop();

    } else {

        player.vy += CFG.gravity * dt;

        player.curO2 -= 1.5 * dt;

        if(player.curO2 <= 0) die();

    }

    player.x = Math.max(50, Math.min(canvas.width - 50, player.x + player.vx * dt));

    player.y = Math.min(CFG.seaFloor, player.y + player.vy * dt);

    chests.forEach(c => {

        if (!c.open && Math.hypot(player.x - c.x, player.y - c.y) < 40) {

            c.open = true; player.cash += c.val;

            spawnText(`+$${c.val}`, c.x, c.y - 30, '#f1c40f');

            for(let k=0; k<8; k++) bubbles.push({x: c.x, y: c.y, s: 3, v: 80, col: '#f1c40f'});

        }

    });

    mines.forEach(m => {

        if(m.active && Math.hypot(player.x - m.x, player.y - m.y) < m.r + 15) {

            explodeMine(m);

            if (player.invincibleTimer <= 0) {

                player.curO2 -= 30; 

                spawnText("-30 AIR", player.x, player.y, '#ff4757');

            } else {

                spawnText("BLOCKED!", player.x, player.y, '#00ffff');

            }

            let ang = Math.atan2(player.y - m.y, player.x - m.x);

            player.vx = Math.cos(ang) * 600; player.vy = Math.sin(ang) * 600;

        }

    });

    updateHarpoons(dt);

    updateFish(dt);

    updateEntities(dt);

    state.camY += ((player.y - canvas.height/2) - state.camY) * 4 * dt;

    if(state.camY < -100) state.camY = -100;

    updateUI();

}

function explodeMine(m) {

    m.active = false; state.shake = 20;

    for(let i=0; i<25; i++) bubbles.push({x: m.x, y: m.y, s: Math.random()*8, v: Math.random()*300, col: '#e74c3c'});

    fishes.forEach(f => {

        if (Math.hypot(f.x - m.x, f.y - m.y) < 160) {

            f.hp -= 10; spawnText("-10", f.x, f.y, '#e67e22');

            f.vx = (f.x - m.x) * 4; f.vy = (f.y - m.y) * 4;

        }

    });

}

function updateHarpoons(dt) {

    for (let i = player.harpoons.length - 1; i >= 0; i--) {

        let h = player.harpoons[i];

        if(h.state === 'fired') {

            h.x += h.vx * dt; h.y += h.vy * dt;

            for(let m of mines) {

                if(m.active && Math.hypot(h.x - m.x, h.y - m.y) < m.r + 5) { explodeMine(m); h.state = 'retracting'; break; }

            }

            if (h.state === 'fired') {

                for(let f of fishes) {

                    if(Math.hypot(h.x - f.x, h.y - f.y) < 30 * f.scale) {

                        state.shake = 6; f.hp -= player.harpoonDmg;

                        for(let b=0;b<4;b++) bubbles.push({x: f.x, y: f.y, s: 2, v: 50, col: '#e74c3c'});

                        spawnText(`-${player.harpoonDmg}`, f.x, f.y - 20, '#e74c3c');

                        if(f.hp <= 0) { h.state = 'hooked'; h.target = f; h.vx = 0; h.vy = 0; }

                        else { h.state = 'retracting'; f.aggro = true; f.hitFlash = 0.2; f.vx += h.vx * 0.3; }

                        break;

                    }

                }

            }

            if(Math.hypot(h.x - player.x, h.y - player.y) > h.range) h.state = 'retracting';

        } else if(h.state === 'hooked' || h.state === 'retracting') {

            const ang = Math.atan2(player.y - h.y, player.x - h.x);

            const spd = h.state === 'hooked' ? 500 : 1600;

            h.x += Math.cos(ang) * spd * dt; h.y += Math.sin(ang) * spd * dt;

            if(h.target) { h.target.x = h.x; h.target.y = h.y; h.target.vx = 0; h.target.vy = 0; }

            if(Math.hypot(player.x - h.x, player.y - h.y) < 30) {

                if(h.target) catchFish(h.target);

                player.harpoons.splice(i, 1);

            }

        }

    }

}

function catchFish(f) {

    const idx = fishes.indexOf(f); if (idx === -1) return;

    const cw = player.inventory.reduce((a,b)=>a+b.w,0);

    if(cw + f.w <= player.capacity) {

        player.inventory.push(f); fishes.splice(idx, 1);

        spawnText(`+${f.name}`, player.x, player.y - 50, '#f1c40f');

    } else {

        spawnText("FULL!", player.x, player.y - 50, '#e74c3c');

        f.x += (Math.random()-0.5)*200; f.vx = 200; f.hp = 1;

    }

}

function updateFish(dt) {

    if(fishes.length < 25) {

        const type = FISH_TYPES[Math.floor(Math.random() * FISH_TYPES.length)];

        if (type.isBoss) { if (fishes.find(f => f.isBoss)) return; }

        const sy = Math.max(CFG.waterLevel+200, type.depth[0] + Math.random()*(type.depth[1]-type.depth[0]));

        if(Math.abs(sy - player.y) < 1500) {

             const side = Math.random() < 0.5 ? -100 : canvas.width+100;

             fishes.push({ ...type, x: side, y: sy, vx: (side<0?1:-1)*type.spd, vy: 0, facing: side<0?1:-1, anim: Math.random()*10, hitFlash: 0, maxHp: type.hp });

        }

    }

    let bossActive = false;

    for(let i=fishes.length-1; i>=0; i--) {

        let f = fishes[i];

        let hooked = false; for(let h of player.harpoons) if(h.target === f) hooked = true;

        if(hooked) continue;

        if (f.isBoss) { bossActive = true; updateBossUI(f); }

        if(f.hitFlash > 0) f.hitFlash -= dt;

        f.anim += dt * (f.aggro ? 8 : 4);

        f.x += f.vx * dt; f.y += Math.sin(f.anim) * 0.5;

        if(Math.abs(f.y - player.y) > 2500 && !f.isBoss) { fishes.splice(i,1); continue; }

        if(f.x < -200 || f.x > canvas.width+200) { f.vx *= -1; f.facing *= -1; }

        if(f.aggro) {

            const dist = Math.hypot(player.x - f.x, player.y - f.y);

            if(dist < 300) {

                const ang = Math.atan2(player.y - f.y, player.x - f.x);

                f.vx = Math.cos(ang) * f.spd * 1.4; f.y += Math.sin(ang) * f.spd * 1.4 * dt;

                f.facing = f.vx > 0 ? 1 : -1;

                if(dist < 40 * f.scale && !player.isDashing) {

                    if (player.invincibleTimer <= 0) {

                        player.curO2 -= (f.isBoss ? 40 : 15); state.shake = 10;

                        spawnText((f.isBoss ? "-40" : "-15") + " O2", player.x, player.y, '#e74c3c');

                        player.vx += Math.cos(ang)*400; player.vy += Math.sin(ang)*400;

                        f.x -= Math.cos(ang)*100;

                    } else {

                        // Blocked

                        spawnText("BLOCKED!", player.x, player.y, '#00ffff');

                        player.vx += Math.cos(ang)*200; player.vy += Math.sin(ang)*200;

                    }

                }

            }

        }

    }

    if (!bossActive) document.getElementById('boss-hud').style.display = 'none';

}

function updateBossUI(f) {

    document.getElementById('boss-hud').style.display = 'flex';

    document.getElementById('boss-fill').style.width = `${Math.max(0, (f.hp / f.maxHp) * 100)}%`;

}

function updateEntities(dt) {

    // Spawners

    if(Math.random() < 0.005 && player.y > 1000) o2Bubbles.push({x: Math.random()*canvas.width, y: player.y + 600, vy: -60});

    // Powerups Spawner

    if(Math.random() < 0.002 && player.y > 800) {

        powerups.push({

            x: Math.random()*canvas.width, y: player.y + 600, vy: -30,

            type: Math.random() > 0.5 ? 'shield' : 'capacity'

        });

    }

    // O2 Collision

    for(let i=o2Bubbles.length-1; i>=0; i--) {

        let b = o2Bubbles[i]; b.y += b.vy * dt; b.x += Math.sin(b.y*0.05)*0.5;

        if(Math.hypot(player.x - b.x, player.y - b.y) < 50) {

            player.curO2 = Math.min(player.maxO2, player.curO2 + 25);

            spawnText("+25 O2", player.x, player.y, '#2ecc71'); o2Bubbles.splice(i, 1);

        } else if (b.y < CFG.waterLevel) o2Bubbles.splice(i, 1);

    }

    // Powerups Collision

    for(let i=powerups.length-1; i>=0; i--) {

        let p = powerups[i]; p.y += p.vy * dt;

        if(Math.hypot(player.x - p.x, player.y - p.y) < 50) {

            if(p.type === 'shield') {

                player.invincibleTimer = 10;

                spawnText("SHIELD!", player.x, player.y, '#00ffff');

            } else {

                if(!player.doubleCapacity) {

                    player.doubleCapacity = true;

                    player.capacity *= 2;

                    spawnText("x2 CARGO", player.x, player.y, '#f1c40f');

                } else {

                    spawnText("EXTENDED!", player.x, player.y, '#f1c40f');

                }

            }

            powerups.splice(i, 1);

        } else if (p.y < CFG.waterLevel) powerups.splice(i, 1);

    }

    particles.forEach(p => { p.y += p.v * dt; if(p.y > player.y + 600) p.y = player.y - 600; });

    for(let i=bubbles.length-1; i>=0; i--) {

        let b = bubbles[i]; b.y -= b.v * dt;

        if(b.y < CFG.waterLevel) bubbles.splice(i, 1);

    }

    ambientBubbles.forEach(b => { b.y -= b.v * dt; if(b.y < CFG.waterLevel) b.y = CFG.seaFloor + Math.random()*200; });

    for(let i=floatingTexts.length-1; i>=0; i--) {

        let t = floatingTexts[i]; t.y -= 40 * dt; t.life -= dt;

        if(t.life <= 0) floatingTexts.splice(i, 1);

    }

    lightRays.forEach(r => r.x += Math.sin(state.gameTime * r.s) * 0.2);

}

// --- Rendering ---

function draw() {

    let sx = (Math.random()-0.5)*state.shake, sy = (Math.random()-0.5)*state.shake;

    ctx.save();

    ctx.translate(sx, sy - state.camY);

    // Sky Gradient

    let skyGrad = ctx.createLinearGradient(0, state.camY-100, 0, CFG.waterLevel);

    skyGrad.addColorStop(0, CFG.colors.sky[0]); skyGrad.addColorStop(1, CFG.colors.sky[1]);

    ctx.fillStyle = skyGrad; ctx.fillRect(0, state.camY-100, canvas.width, CFG.waterLevel - (state.camY-100));

    // Water Gradient

    let waterGrad = ctx.createLinearGradient(0, CFG.waterLevel, 0, CFG.seaFloor);

    waterGrad.addColorStop(0, CFG.colors.surface[0]); 

    waterGrad.addColorStop(0.4, CFG.colors.surface[1]); 

    waterGrad.addColorStop(1, CFG.colors.surface[2]);

    ctx.fillStyle = waterGrad; ctx.fillRect(0, CFG.waterLevel, canvas.width, CFG.seaFloor+1000);

    // Ambient Bubbles

    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';

    ambientBubbles.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, b.s, 0, Math.PI*2); ctx.fill(); });

    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';

    particles.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, p.s, 0, Math.PI*2); ctx.fill(); });

    ctx.fillStyle = patRock || '#2d3436';

    if (rocksL.length > 0) {

        ctx.beginPath(); ctx.moveTo(rocksL[0].x, rocksL[0].y); for(let p of rocksL) ctx.lineTo(p.x, p.y); ctx.lineTo(-500, CFG.seaFloor); ctx.lineTo(-500, CFG.waterLevel); ctx.fill();

        ctx.beginPath(); ctx.moveTo(rocksR[0].x, rocksR[0].y); for(let p of rocksR) ctx.lineTo(p.x, p.y); ctx.lineTo(canvas.width+500, CFG.seaFloor); ctx.lineTo(canvas.width+500, CFG.waterLevel); ctx.fill();

    }

    if(player.y > CFG.seaFloor - 1000) {

        ctx.fillStyle = patSand || '#95a5a6'; ctx.fillRect(0, CFG.seaFloor, canvas.width, 500);

        // Distant seabed layer

        ctx.fillStyle = '#000408'; ctx.fillRect(0, CFG.seaFloor + 300, canvas.width, 500);

    }

    chests.forEach(c => {

        ctx.save(); ctx.translate(c.x, c.y); ctx.shadowBlur = 15; ctx.shadowColor = '#f1c40f';

        ctx.fillStyle = c.open ? '#555' : '#f1c40f'; ctx.fillRect(-15, -20, 30, 20);

        ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.strokeRect(-15, -20, 30, 20); ctx.restore();

    });

    mines.forEach(m => {

        if(!m.active) return;

        ctx.save(); ctx.translate(m.x, m.y);

        ctx.fillStyle = '#2d3436'; ctx.beginPath(); ctx.arc(0, 0, m.r, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = (Math.floor(state.gameTime*4)%2===0) ? '#e74c3c' : '#550000';

        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();

        ctx.strokeStyle = '#2d3436'; ctx.lineWidth = 3;

        for(let i=0; i<8; i++) {

            ctx.rotate(Math.PI/4); ctx.beginPath(); ctx.moveTo(m.r, 0); ctx.lineTo(m.r+6, 0); ctx.stroke();

        }

        ctx.restore();

    });

    o2Bubbles.forEach(b => {

        ctx.save(); ctx.translate(b.x, b.y);

        let g = ctx.createRadialGradient(0,0,2, 0,0,15); g.addColorStop(0,'white'); g.addColorStop(0.5,'#2ecc71'); g.addColorStop(1,'transparent');

        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = 'white'; ctx.font = '700 10px Fredoka'; ctx.fillText("O2", -7, 4); ctx.restore();

    });

    powerups.forEach(p => {

        ctx.save(); ctx.translate(p.x, p.y);

        if(p.type === 'shield') {

            // Shield Icon

            ctx.shadowBlur = 15; ctx.shadowColor = '#00ffff';

            ctx.fillStyle = 'rgba(0, 255, 255, 0.3)'; ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();

            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.stroke();

        } else {

            // Box Icon

            ctx.shadowBlur = 15; ctx.shadowColor = '#f1c40f';

            ctx.fillStyle = '#f1c40f'; ctx.fillRect(-12, -12, 24, 24);

            ctx.fillStyle = '#e67e22'; ctx.fillRect(-12, -4, 24, 8);

        }

        ctx.restore();

    });

    fishes.forEach(f => { 

        let hooked = false;

        for(let h of player.harpoons) if(h.target === f) hooked = true;

        if(!hooked) drawFishTextured(f); 

    });

    player.harpoons.forEach(h => drawHarpoon(h));

    drawPlayer();

    if(player.y < CFG.waterLevel + 600) {

        ctx.save(); ctx.globalCompositeOperation = 'overlay';

        ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 3;

        for(let i=0; i<3; i++) {

            ctx.beginPath();

            for(let x=0; x<canvas.width; x+=40) {

                let y = CFG.waterLevel + 50 + (i*80) + Math.sin(x*0.01 + waveOffset + i)*15;

                if(x===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);

            }

            ctx.stroke();

        }

        ctx.restore();

        ctx.fillStyle = 'rgba(52, 152, 219, 0.5)'; ctx.beginPath(); ctx.moveTo(0, CFG.waterLevel);

        for(let x=0; x<=canvas.width; x+=20) {

            let y = Math.sin(x*0.01 + waveOffset*2) * 5; ctx.lineTo(x, CFG.waterLevel + y);

        }

        ctx.lineTo(canvas.width, CFG.waterLevel+50); ctx.lineTo(0, CFG.waterLevel+50); ctx.fill();

    }

    // Boat

    ctx.save();

    let bob = Math.sin(state.gameTime * 2) * 5;

    let rock = Math.sin(state.gameTime * 1.5) * 0.05;

    ctx.translate(canvas.width/2, CFG.waterLevel + bob); ctx.rotate(rock);

    ctx.fillStyle = '#ecf0f1'; ctx.beginPath(); ctx.moveTo(-70, -20); ctx.lineTo(80, -20); ctx.lineTo(90, 0); ctx.lineTo(70, 20); ctx.lineTo(-60, 20); ctx.closePath(); ctx.fill(); ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 2; ctx.stroke();

    ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(-60, 20); ctx.lineTo(70, 20); ctx.quadraticCurveTo(50, 40, -50, 40); ctx.closePath(); ctx.fill();

    ctx.fillStyle = '#f1c40f'; ctx.fillRect(-20, -50, 50, 30);

    ctx.fillStyle = '#3498db'; ctx.fillRect(-10, -40, 10, 10); ctx.fillRect(10, -40, 10, 10);

    ctx.beginPath(); ctx.moveTo(5, -50); ctx.lineTo(5, -80); ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 3; ctx.stroke();

    ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(5, -80); ctx.lineTo(25, -70); ctx.lineTo(5, -60); ctx.fill();

    ctx.restore();

    drawLighting();

    floatingTexts.forEach(t => { 

        ctx.save(); ctx.translate(t.x, t.y);

        ctx.shadowColor = 'black'; ctx.shadowBlur = 4;

        ctx.fillStyle = t.col; ctx.font = '800 20px Fredoka'; ctx.fillText(t.txt, 0, 0);

        ctx.restore();

    });

    ctx.restore();

}

function drawPlayer() {

    ctx.save(); ctx.translate(player.x, player.y);

    let rot = player.aimAngle; let flip = 1;

    if(Math.abs(rot) > Math.PI/2) { flip = -1; rot = Math.PI - rot; }

    ctx.scale(1, flip); ctx.rotate(rot);

    // Shield Effect

    if (player.invincibleTimer > 0) {

        ctx.strokeStyle = `rgba(0, 255, 255, ${Math.abs(Math.sin(state.gameTime*10))})`; 

        ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI*2); ctx.stroke();

    }

    if(player.isDashing) {

        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';

        ctx.beginPath(); ctx.moveTo(-30, -10); ctx.lineTo(-60, 0); ctx.lineTo(-30, 10); ctx.fill();

    }

    let fin = Math.sin(state.gameTime*15)*5;

    ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(-15, 5); ctx.lineTo(-30, 10+fin); ctx.lineTo(-28, 0); ctx.fill();

    ctx.beginPath(); ctx.moveTo(-15, -5); ctx.lineTo(-30, -10-fin); ctx.lineTo(-28, 0); ctx.fill();

    ctx.fillStyle = '#f1c40f'; drawRoundRect(ctx, -10, -12, 20, 8, 4);

    ctx.fillStyle = '#34495e'; ctx.beginPath(); ctx.ellipse(0, 0, 22, 10, 0, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = '#7bed9f'; ctx.beginPath(); ctx.arc(12, -2, 6, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = player.powLvl >= 3 ? '#341f97' : '#95a5a6'; 

    ctx.fillRect(5, 2, 15, 4);

    if(player.powLvl >= 5) { ctx.fillRect(5, -2, 15, 2); ctx.fillRect(5, 6, 15, 2); }

    if(state.screen === 'playing') {

        ctx.globalCompositeOperation = 'screen';

        ctx.strokeStyle = 'rgba(255,0,0,0.4)'; ctx.lineWidth = 2;

        ctx.beginPath(); ctx.moveTo(20, 4); ctx.lineTo(300, 4); ctx.stroke();

        ctx.globalCompositeOperation = 'source-over';

    }

    ctx.restore();

}

function drawFishTextured(f) {

    ctx.save();

    ctx.translate(f.x, f.y);

    ctx.scale(f.facing * f.scale, f.scale);

    if (f.hitFlash > 0) {

        ctx.fillStyle = '#fff';

        ctx.strokeStyle = '#fff';

    } else {

        ctx.fillStyle = f.col;

        ctx.strokeStyle = 'rgba(0,0,0,0.2)';

    }

    ctx.lineWidth = 1;

    switch(f.type) {

        case 'jelly': drawJellyfish(f); break;

        case 'shark': drawShark(f); break;

        case 'boss': drawLeviathan(f); break;

        case 'ray': drawStingray(f); break;

        case 'puffer': drawPuffer(f); break;

        case 'angler': drawAnglerfish(f); break;

        default: drawGenericFish(f); break;

    }

    // Health Bar

    if(f.hp < f.maxHp && f.hitFlash <= 0 && f.type !== 'jelly') {

        ctx.fillStyle = 'red'; ctx.fillRect(-10, -20, 20, 4);

        ctx.fillStyle = '#00ff00'; ctx.fillRect(-10, -20, 20 * (f.hp/f.maxHp), 4);

    }

    ctx.restore();

}

function drawLeviathan(f) {

    // Ancient Serpent Body

    let wiggle = Math.sin(f.anim * 0.5) * 5;

    // Main Body Segment

    ctx.beginPath();

    ctx.moveTo(40, 0);

    ctx.quadraticCurveTo(20, -25, -40, -15 + wiggle);

    ctx.lineTo(-60, 0 + wiggle);

    ctx.lineTo(-40, 15 + wiggle);

    ctx.quadraticCurveTo(20, 25, 40, 0);

    ctx.fill();

    // Armor Plates

    if (!f.hitFlash) {

        ctx.fillStyle = '#a93226'; // Darker red plates

        ctx.beginPath(); ctx.moveTo(10, -18); ctx.lineTo(-10, -12 + wiggle); ctx.lineTo(-10, 12 + wiggle); ctx.lineTo(10, 18); ctx.fill();

        ctx.beginPath(); ctx.moveTo(-20, -15 + wiggle); ctx.lineTo(-40, -10 + wiggle); ctx.lineTo(-40, 10 + wiggle); ctx.lineTo(-20, 15 + wiggle); ctx.fill();

    }

    // Massive Tail

    ctx.fillStyle = f.col;

    if (f.hitFlash > 0) ctx.fillStyle = '#fff';

    ctx.beginPath();

    ctx.moveTo(-60, 0 + wiggle);

    ctx.lineTo(-90, -20 + wiggle * 2);

    ctx.lineTo(-80, 0 + wiggle);

    ctx.lineTo(-90, 20 + wiggle * 2);

    ctx.fill();

    // Glowing Eye

    if (!f.hitFlash) {

        ctx.fillStyle = '#f1c40f';

        ctx.shadowBlur = 20; ctx.shadowColor = '#f1c40f';

        ctx.beginPath(); ctx.arc(25, -8, 4, 0, Math.PI*2); ctx.fill();

        ctx.shadowBlur = 0;

    }

    // Spikes

    ctx.fillStyle = '#5c1515';

    ctx.beginPath(); ctx.moveTo(-10, -12 + wiggle); ctx.lineTo(-5, -30 + wiggle); ctx.lineTo(0, -15 + wiggle); ctx.fill();

}

function drawGenericFish(f) {

    ctx.beginPath(); ctx.moveTo(15, 0); ctx.bezierCurveTo(5, -15, -15, -10, -20, 0); ctx.bezierCurveTo(-15, 10, 5, 15, 15, 0); ctx.fill();

    if (!f.hitFlash) {

        ctx.beginPath(); for(let i=-10; i<10; i+=5) { ctx.moveTo(i, -5); ctx.quadraticCurveTo(i+2, 0, i, 5); } ctx.stroke();

    }

    let tail = Math.sin(f.anim)*5;

    ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(-30, -10+tail); ctx.lineTo(-30, 10+tail); ctx.closePath(); ctx.fill();

    drawEye(8, -4);

}

function drawPuffer(f) {

    ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill();

    if(f.spikes) {

        for(let i=0; i<8; i++) {

            let a = i*(Math.PI/4);

            ctx.beginPath(); ctx.moveTo(Math.cos(a)*15, Math.sin(a)*15);

            ctx.lineTo(Math.cos(a)*22, Math.sin(a)*22);

            ctx.lineTo(Math.cos(a+0.2)*15, Math.sin(a+0.2)*15); ctx.fill();

        }

    }

    let tail = Math.sin(f.anim)*3;

    ctx.beginPath(); ctx.moveTo(-15, 0); ctx.lineTo(-22, -5+tail); ctx.lineTo(-22, 5+tail); ctx.closePath(); ctx.fill();

    drawEye(5, -5);

}

function drawJellyfish(f) {

    ctx.globalAlpha = 0.7;

    ctx.beginPath(); ctx.arc(0, -5, 15, Math.PI, 0); ctx.lineTo(15, 5); 

    ctx.bezierCurveTo(5, 0, -5, 0, -15, 5); ctx.closePath(); ctx.fill();

    ctx.globalAlpha = 0.5;

    ctx.strokeStyle = f.col; ctx.lineWidth = 2;

    let tOffset = Math.sin(f.anim)*3;

    for(let i=-10; i<=10; i+=5) {

        ctx.beginPath(); ctx.moveTo(i, 5);

        ctx.quadraticCurveTo(i+tOffset, 15, i, 25);

        ctx.quadraticCurveTo(i-tOffset, 35, i, 45); ctx.stroke();

    }

    ctx.globalAlpha = 1.0;

}

// --- REDESIGNED ANGLERFISH ---

function drawAnglerfish(f) {

    // Bulbous Body

    ctx.beginPath();

    ctx.ellipse(-5, 0, 25, 20, 0, 0, Math.PI * 2);

    ctx.fill();

    // Massive Underbite Jaw

    ctx.beginPath();

    ctx.moveTo(5, 5);

    ctx.quadraticCurveTo(25, 25, 40, 15); // Lower lip

    ctx.lineTo(10, 25);

    ctx.closePath();

    ctx.fill();

    // Needle Teeth (White)

    if (!f.hitFlash) ctx.fillStyle = 'white';

    ctx.beginPath();

    // Upper teeth

    ctx.moveTo(15, 0); ctx.lineTo(17, 8); ctx.lineTo(19, 0);

    ctx.moveTo(22, 0); ctx.lineTo(24, 6); ctx.lineTo(26, 0);

    // Lower teeth (prominent & irregular)

    ctx.moveTo(25, 18); ctx.lineTo(27, 8); ctx.lineTo(29, 18);

    ctx.moveTo(32, 15); ctx.lineTo(34, 5); ctx.lineTo(36, 15);

    ctx.moveTo(38, 12); ctx.lineTo(39, 4); ctx.lineTo(40, 12);

    ctx.fill();

    // Revert color for body parts if not flashing

    if (!f.hitFlash) ctx.fillStyle = f.col;

    // Lure Stalk

    ctx.strokeStyle = '#555';

    ctx.lineWidth = 3;

    let sway = Math.sin(f.anim * 0.5) * 8;

    ctx.beginPath();

    ctx.moveTo(5, -18); // Forehead

    ctx.quadraticCurveTo(30 + sway, -50, 50 + sway, -30);

    ctx.stroke();

    // Glowing Bulb

    if (!f.hitFlash) {

        ctx.fillStyle = '#00ffff';

        ctx.shadowBlur = 20; ctx.shadowColor = '#00ffff';

    }

    ctx.beginPath(); ctx.arc(50 + sway, -30, 6, 0, Math.PI*2); ctx.fill();

    ctx.shadowBlur = 0; // Reset shadow

    // Small, Mean Eye

    if (!f.hitFlash) {

        ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.arc(10, -10, 4, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(11, -10, 1.5, 0, Math.PI*2); ctx.fill();

    }

    // Tattered Tail

    let tail = Math.sin(f.anim) * 3;

    if (!f.hitFlash) ctx.fillStyle = f.col; // Ensure body color

    ctx.beginPath();

    ctx.moveTo(-28, 0);

    ctx.lineTo(-40, -12 + tail);

    ctx.lineTo(-35, 0 + tail); // Jagged middle

    ctx.lineTo(-40, 12 + tail);

    ctx.closePath();

    ctx.fill();

}

function drawShark(f) {

    ctx.beginPath(); ctx.moveTo(25, 0); ctx.quadraticCurveTo(10, -12, -15, -8);

    ctx.lineTo(-30, 0); ctx.lineTo(-15, 8); ctx.quadraticCurveTo(10, 12, 25, 0); ctx.fill();

    ctx.beginPath(); ctx.moveTo(5, -10); ctx.lineTo(15, -25); ctx.lineTo(20, -12); ctx.fill();

    let tail = Math.sin(f.anim)*8;

    ctx.beginPath(); ctx.moveTo(-30, 0); ctx.lineTo(-45, -15+tail); 

    ctx.lineTo(-38, 0); ctx.lineTo(-45, 15+tail); ctx.closePath(); ctx.fill();

    drawEye(15, -4);

    if(!f.hitFlash) {

        ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1.5;

        for(let i=0; i<3; i++) { ctx.beginPath(); ctx.moveTo(0+i*3, -5); ctx.lineTo(0+i*3, 5); ctx.stroke(); }

    }

}

function drawStingray(f) {

    ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(0, -15); ctx.lineTo(-20, 0); ctx.lineTo(0, 15); ctx.closePath(); ctx.fill();

    let flap = Math.sin(f.anim)*10;

    ctx.beginPath(); ctx.moveTo(0, -15); ctx.quadraticCurveTo(20, -15-flap, 35, 0); ctx.quadraticCurveTo(20, 15+flap, 0, 15); ctx.fill();

    ctx.lineWidth = 2;

    ctx.beginPath(); ctx.moveTo(-20, 0); ctx.quadraticCurveTo(-40, Math.sin(f.anim)*5, -60, 0); ctx.stroke();

    drawEye(5, -5); drawEye(5, 5);

}

function drawEye(x, y) {

    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(x+1, y, 1.5, 0, Math.PI*2); ctx.fill();

}

function drawHarpoon(h) {

    if(h.state === 'ready') return;

    ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 1.5;

    ctx.beginPath(); ctx.moveTo(player.x, player.y);

    if(h.state === 'retracting') ctx.quadraticCurveTo((player.x+h.x)/2, (player.y+h.y)/2+20, h.x, h.y); else ctx.lineTo(h.x, h.y);

    ctx.stroke();

    ctx.save(); ctx.translate(h.x, h.y);

    let ang = (h.state==='retracting') ? Math.atan2(player.y-h.y, player.x-h.x) : Math.atan2(h.vy, h.vx);

    ctx.rotate(ang);

    ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.moveTo(0, -3); ctx.lineTo(15, 0); ctx.lineTo(0, 3); ctx.fill();

    ctx.restore();

    if(h.target) drawFishTextured(h.target);

}

function drawLighting() {

    if(!maskCanvas.width) return;

    const depth = player.y - CFG.waterLevel;

    const dStart = CFG.darkDepth;

    if(depth < dStart) {

        ctx.save(); ctx.globalCompositeOperation = 'overlay';

        let g = ctx.createLinearGradient(0, CFG.waterLevel, 0, CFG.waterLevel+600);

        g.addColorStop(0, 'rgba(255,255,255,0.2)'); g.addColorStop(1, 'transparent');

        ctx.fillStyle = g;

        lightRays.forEach(r => { ctx.beginPath(); ctx.moveTo(r.x, CFG.waterLevel); ctx.lineTo(r.x+Math.sin(r.a)*100, CFG.waterLevel+600); ctx.lineTo(r.x+r.w, CFG.waterLevel); ctx.fill(); });

        ctx.restore(); return;

    }

    const intensity = Math.min(0.96, (depth-dStart)/1500);

    maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

    maskCtx.fillStyle = `rgba(0, 5, 15, ${intensity})`;

    maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);

    maskCtx.globalCompositeOperation = 'destination-out';

    let gAmb = maskCtx.createRadialGradient(player.x, player.y-state.camY, 20, player.x, player.y-state.camY, 180);

    gAmb.addColorStop(0, 'white'); gAmb.addColorStop(1, 'transparent');

    maskCtx.fillStyle = gAmb; maskCtx.beginPath(); maskCtx.arc(player.x, player.y-state.camY, 180, 0, Math.PI*2); maskCtx.fill();

    maskCtx.save(); maskCtx.translate(player.x, player.y-state.camY); maskCtx.rotate(player.aimAngle);

    let gCone = maskCtx.createRadialGradient(0, 0, 10, 0, 0, 450);

    gCone.addColorStop(0, 'rgba(255,255,255,0.9)'); gCone.addColorStop(1, 'transparent');

    maskCtx.fillStyle = gCone;

    maskCtx.beginPath(); maskCtx.moveTo(0, 0); maskCtx.lineTo(450, -100); maskCtx.quadraticCurveTo(500, 0, 450, 100); maskCtx.lineTo(0, 0); maskCtx.fill();

    maskCtx.restore();

    [...fishes, ...o2Bubbles, ...powerups].forEach(e => {

        if(e.glow || e.type === 'shield' || e.type === 'capacity') {

            let g = maskCtx.createRadialGradient(e.x, e.y-state.camY, 5, e.x, e.y-state.camY, 100);

            g.addColorStop(0, 'rgba(255,255,255,0.8)'); g.addColorStop(1, 'transparent');

            maskCtx.fillStyle = g; maskCtx.beginPath(); maskCtx.arc(e.x, e.y-state.camY, 100, 0, Math.PI*2); maskCtx.fill();

        }

    });

    ctx.drawImage(maskCanvas, 0, 0);

}

function spawnText(txt, x, y, col) { floatingTexts.push({txt, x, y, col, life: 1.0}); }

function openShop() {

    state.screen = 'shop'; player.curO2 = player.maxO2;

    player.doubleCapacity = false; player.invincibleTimer = 0; player.capacity = (10 + (player.suitLvl-1)*5);

    document.getElementById('modal-overlay').style.display = 'flex'; updateShopUI();

}

function updateShopUI() {

    document.getElementById('sell-val').innerText = player.inventory.reduce((a,b)=>a+b.val,0);

    document.getElementById('tank-lvl').innerText = player.tankLvl; document.getElementById('tank-cost').innerText = player.tankCost;

    document.getElementById('suit-lvl').innerText = player.suitLvl; document.getElementById('suit-cost').innerText = player.suitCost;

    document.getElementById('pow-lvl').innerText = player.powLvl; document.getElementById('pow-cost').innerText = player.powCost;

    let desc = "(Base)"; if(player.powLvl===2) desc="(Sniper)"; if(player.powLvl>=4) desc="(Trident)";

    document.getElementById('pow-desc').innerText = desc;

    const setBtn = (id, cost) => {

        const b = document.getElementById(id);

        if(player.cash < cost) b.classList.add('disabled'); else b.classList.remove('disabled');

    };

    setBtn('buy-tank', player.tankCost); setBtn('buy-suit', player.suitCost); setBtn('buy-pow', player.powCost);

}

document.getElementById('sell-btn').addEventListener('click', () => {

    let val = player.inventory.reduce((a,b)=>a+b.val,0);

    if(val > 0) { player.cash += val; player.inventory = []; spawnText("SOLD!", player.x, player.y, '#2ecc71'); updateShopUI(); }

});

document.getElementById('buy-tank').addEventListener('click', () => {

    if(player.cash >= player.tankCost) { player.cash-=player.tankCost; player.maxO2+=25; player.tankLvl++; player.tankCost=Math.floor(player.tankCost*1.5); updateShopUI(); }

});

document.getElementById('buy-suit').addEventListener('click', () => {

    if(player.cash >= player.suitCost) { 

        player.cash-=player.suitCost; 

        player.capacity = (10 + (player.suitLvl)*5); // Immediate update

        player.suitLvl++; 

        player.suitCost=Math.floor(player.suitCost*1.5); 

        updateShopUI(); 

    }

});

document.getElementById('buy-pow').addEventListener('click', () => {

    if(player.cash >= player.powCost) { player.cash-=player.powCost; player.powLvl++; player.harpoonDmg++; if(player.powLvl>=5) player.harpoonCount=3; player.powCost=Math.floor(player.powCost*1.5); updateShopUI(); }

});

document.getElementById('dive-btn').addEventListener('click', () => {

    document.getElementById('modal-overlay').style.display = 'none'; state.screen = 'playing';

    player.y = CFG.waterLevel + 60; player.vy = 100; player.vx = 0; state.lastTime = performance.now();

});

function die() {

    state.screen = 'dead';

    document.getElementById('toast-msg').innerText = "EMERGENCY RESCUE...";

    document.getElementById('toast-msg').style.opacity = 1;

    player.inventory = [];

    setTimeout(() => { 

        player.x=canvas.width/2; player.y=CFG.waterLevel-50; player.curO2=player.maxO2; 

        document.getElementById('toast-msg').style.opacity = 0;

        openShop(); 

    }, 3000);

}

function updateUI() {

    const pct = Math.max(0, (player.curO2 / player.maxO2) * 100);

    document.getElementById('oxygen-bar').style.width = `${pct}%`;

    document.getElementById('depth-val').innerText = Math.floor(Math.max(0, player.y - CFG.waterLevel) / 10);

    document.getElementById('cash-val').innerText = player.cash;

    const w = player.inventory.reduce((a,b)=>a+b.w,0);

    document.getElementById('weight-val').innerText = w;

    document.getElementById('max-weight-val').innerText = player.capacity;

    document.getElementById('weight-val').style.color = w >= player.capacity ? '#e74c3c' : 'white';

}

function loop(now) {

    try {

        const dt = Math.min((now - state.lastTime)/1000, 0.1); state.lastTime = now;

        draw();

        if(state.screen === 'playing') update(dt);

        requestAnimationFrame(loop);

    } catch (e) {

        document.getElementById('error-log').style.display = 'block';

        document.getElementById('error-log').innerText = "CRITICAL ERROR: " + e.message;

    }

}

window.onload = init;
</script>
</body>
</html>
 